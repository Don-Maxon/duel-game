для реализации данного задания я использовал нативный JS для самого алгоритма и вспомогательных функций
и HTML для создания минимального интерфейса для удобства проверки, без использования CSS, т.к. основыной акцент задания 
поставлена на работе с JS.

Суть работы моего "ИИ":
У ИИ  есть две фазы действия: нападенеие(когда ему нужно достать карту большего значения, чем игрок)
и защита(когда ии нужно достать карту не меньшую, чем у игрока, а в идеале раную его карте)
Основной алгоритм кода находится в функции переданной обработчику событий кнопки gamer_attacks_button
для каждой из этих фаз(атака/нападение) я использовал отедльные фунцкии:
в ситуации когда нападает игрок(round_point = 1), запскается фунцкия зашиты ии aiChoiceGeneratorProtection(ai_cards), которая принимает набор карт ии, 
которые ещё есть у ии в наличии, аналогично при (round_point = 2) запскается фунцкия атаки ии aiChoiceGeneratorAttack(ai_cards).

Когда ии защищается, то мы высчитываем индекс карты находящйся примерно по середине массива наших карт, (поскольку изначально они расположены по возрастанию, то при 
удалении карт из массива они всё равно будут идти от меньшей к большей), далее найдя нужный индекс я создаю массив в который записываю ещё карты слева и справа от выбранной карты
и уже из этого массива выбираю одну из них (это сделано для добавления разнообразия при выборе карты).

Когда ии атакует, то мы используем либо самую малую крту(или близкие к ней), либо самую большую(или близкие к ней), за счет этого игрок играя с ии не знает точно, 
нужно ли ему при защите выбрать карту большого, среднего или малого значения, за счет чего может быть ситуация когда игрок теряет 11, чтобы зашититься от 1, или же
наоборот ставит 2 против 10.

Таким образом ИИ играет от зашиты "средниими" картами и  комбинацией случайного чередования "ложных" атак "минимальными" картами и сильных атак картами с максимальными значениями,
не используя при этом данные о картах игрока
